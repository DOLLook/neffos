package ws

import (
	"bytes"
	"context"
	"errors"
	"net"
	"net/http"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"time"
)

type (
	Socket interface {
		NetConn() net.Conn
		Request() *http.Request

		ReadText(timeout time.Duration) (body []byte, err error)
		WriteText(body []byte, timeout time.Duration) error
	}

	// Conn interface {
	// 	Socket() Socket
	// 	ID() string
	// 	String() string

	// 	Write(msg Message) bool
	// 	Ask(ctx context.Context, msg Message) (Message, error)

	// 	Connect(ctx context.Context, namespace string) (NSConn, error)
	// 	WaitConnect(ctx context.Context, namespace string) (NSConn, error)
	// 	Namespace(namespace string) NSConn
	// 	DisconnectAll(ctx context.Context) error

	// 	IsClient() bool
	// 	Server() *Server

	// 	Close()
	// 	IsClosed() bool
	// }

	// NSConn interface {
	// 	Conn() Conn

	// 	Emit(event string, body []byte) bool
	// 	Ask(ctx context.Context, event string, body []byte) (Message, error)

	// 	JoinRoom(ctx context.Context, roomName string) (Room, error)
	// 	Room(roomName string) Room
	// 	LeaveAll(ctx context.Context) error

	// 	Disconnect(ctx context.Context) error
	// }

	// Room interface {
	// 	NSConn() NSConn

	// 	Emit(event string, body []byte) bool
	// 	Leave(ctx context.Context) error
	// }
)

// var (
// 	_ Conn   = (*conn)(nil)
// 	_ NSConn = (*nsConn)(nil)
// 	_ Room   = (*room)(nil)
// )

type Conn struct {
	// the ID generated by `Server#IDGenerator`.
	id string

	// the gorilla or gobwas socket.
	socket Socket

	// non-nil if server-side connection.
	server *Server
	// when sever is ready to handle messages, ack and queue is available, see `Server#ServeHTTP.?OnConnect!=nil`.
	serverReadyWaiter *waiter

	// maximum wait time allowed to read a message from the connection.
	// Defaults to no timeout.
	readTimeout time.Duration
	// maximum wait time allowed to write a message to the connection.
	// Defaults to no timeout.
	writeTimeout time.Duration

	// the defined namespaces, allowed to connect.
	namespaces Namespaces

	// more than 0 if acknowledged.
	acknowledged *uint32

	// the connection's current connected namespace.
	connectedNamespaces      map[string]*NSConn
	connectedNamespacesMutex sync.RWMutex

	// messages that this connection waits for a reply.
	waitingMessages      map[string]chan Message
	waitingMessagesMutex sync.RWMutex

	// used to fire `conn#Close` once.
	closed *uint32
	// useful to terminate the broadcaster, see `Server#ServeHTTP.waitMessage`.
	closeCh chan struct{}
}

type waiter struct {
	locked *uint32
	ready  *uint32
	err    error
	// mu     sync.Mutex
	ch chan struct{}
}

func newWaiter() *waiter {
	return &waiter{
		locked: new(uint32),
		ready:  new(uint32),
		ch:     make(chan struct{}),
	}
}

func (w *waiter) isReady() bool {
	if w == nil { // it's nil if not server-side connection; it's always "ready" to send/receive events on client-side.
		return true
	}

	return atomic.LoadUint32(w.ready) > 0
}

func (w *waiter) wait() error {
	if w == nil {
		return nil
	}

	if w.isReady() {
		// println("waiter: wait() is Ready")
		return w.err // no need to wait.
	}

	if atomic.CompareAndSwapUint32(w.locked, 0, 1) {
		// println("waiter: lock")
		<-w.ch
	}

	return w.err
}

func (w *waiter) unwait(err error) {
	if w == nil || w.isReady() {
		// println("waiter: it's ready, do nothing and return")
		return
	}

	w.err = err
	// println("waiter: mark ready")
	// at any case mark it as ready for future `wait` call to exit immediately.
	atomic.StoreUint32(w.ready, 1)
	if atomic.CompareAndSwapUint32(w.locked, 1, 0) { // unlock once.
		// fmt.Printf("waiter: unlock and set error: %v\n", err)

		close(w.ch)
	}
}

func newConn(socket Socket, namespaces Namespaces) *Conn {
	return &Conn{
		socket:              socket,
		namespaces:          namespaces,
		acknowledged:        new(uint32),
		connectedNamespaces: make(map[string]*NSConn),
		waitingMessages:     make(map[string]chan Message),
		closed:              new(uint32),
		closeCh:             make(chan struct{}),
	}
}

func (c *Conn) ID() string {
	return c.id
}

func (c *Conn) String() string {
	return c.ID()
}

func (c *Conn) Socket() Socket {
	return c.socket
}

func (c *Conn) IsClient() bool {
	return c.server == nil
}

func (c *Conn) Server() *Server {
	if c.IsClient() {
		return nil
	}

	return c.server
}

var (
	ackBinary      = []byte("ack")
	ackOKBinary    = []byte("ack_ok")
	ackNotOKBinary = []byte("ack_err")
)

func (c *Conn) isAcknowledged() bool {
	return atomic.LoadUint32(c.acknowledged) > 0
}

// blocking and waits for err if any, on the `Server#OnConnect`
func (c *Conn) clientAck() error {
	waiter := newWaiter()

	go func() {
		for {
			b, err := c.socket.ReadText(c.readTimeout)
			if err != nil {
				waiter.unwait(err)
				return
			}
			//	println("[BINARY] client ack: " + string(b))

			if bytes.HasPrefix(b, ackNotOKBinary) {
				errText := string(b[len(ackNotOKBinary):])
				//println("client ack: got an error: " + errText)
				err = errors.New(errText)
				waiter.unwait(err)
				return
			}

			if bytes.HasPrefix(b, ackBinary) {
				//println("client ack: all OK, set ack to 1 and set ID.")
				id := string(b[len(ackBinary):])
				c.id = id
				atomic.StoreUint32(c.acknowledged, 1)
				c.socket.WriteText(ackOKBinary, c.writeTimeout)
				waiter.unwait(nil)
				return
			}

			continue
		}
	}()

	//println("client ack: send ackBinary to start the process")
	c.socket.WriteText(ackBinary, c.writeTimeout)

	//println("client ack: wait for server response")
	err := waiter.wait()
	if err != nil {
		c.Close()
	}
	//println("client ack: got server response", err)
	return err
}

// no blocking.
func (c *Conn) serverAck() {
	go func() {
		defer c.Close()

		var (
			queue       = make([]*Message, 0)
			queueMutex  = new(sync.Mutex)
			handleQueue = func() {
				// ready to handle queue when server is ready (if server-side conn).
				// c.serverReadyWaiter.wait()

				queueMutex.Lock()
				defer queueMutex.Unlock()

				for _, msg := range queue {
					c.handleMessage(*msg)
				}

				queue = queue[0:0]
			}
			allowNativeMessages = c.namespaces[""] != nil && c.namespaces[""][OnNativeMessage] != nil
		)

		for {
			b, err := c.socket.ReadText(c.readTimeout)
			if err != nil {
				//println("server ack: ReadText error: " + err.Error())
				//	c.Close()
				return
			}
			// println("[BINARY] server ack: " + string(b))
			if bytes.HasPrefix(b, ackBinary) {
				if len(b) == len(ackBinary) {
					//println("server ack: client sent ackBinary, wait for serverReadyWaiter...")
					err := c.serverReadyWaiter.wait()
					// fmt.Printf("server ack: we have a response from OnConnect or no: %v\n", err)
					if err == nil {
						// it's ok send ack.
						c.socket.WriteText(append(ackBinary, []byte(c.id)...), c.writeTimeout)
					} else {
						// it's not Ok, send error which client's Dial should return.
						// See `clientAck`.
						//println("server ack: send the ack Not OK:" + string(append(ackNotOKBinary, []byte(err.Error())...)))
						c.socket.WriteText(append(ackNotOKBinary, []byte(err.Error())...), c.writeTimeout)
						// c.Close()
						return
					}
				} else {
					// its ackOK, answer from client when ID received and it's ready for write/read.
					//println("server ack: all OK, set ack to 1 and start reader.", string(b))
					atomic.StoreUint32(c.acknowledged, 1)
					handleQueue()
					// go c.startReader()
					// return
				}
				continue
			}

			msg := deserializeMessage(nil, b, allowNativeMessages)
			if msg.isInvalid {
				// fmt.Printf("%s[%d] is invalid payload\n", b, len(b))
				continue
			}

			if !c.isAcknowledged() { // || !c.serverReadyWaiter.isReady() {
				queueMutex.Lock()
				queue = append(queue, &msg)
				queueMutex.Unlock()
				continue
			}

			// if !c.handleMessage(msg) {
			// 	return
			// }

			go c.handleMessage(msg)
		}
	}()
}

// func (c *Conn) ack() error {
// 	go func() {
// 		for {
// 			b, err := c.socket.ReadText(c.readTimeout)
// 			if err != nil {
// 				return
// 			}

// 			if c.IsClient() && bytes.HasPrefix(b, ackNotOKBinary) {
// 				errText := string(b[len(ackNotOKBinary):])
// 				err = errors.New(errText)
// 				return
// 			}

// 			if bytes.HasPrefix(b, ackBinary) {
// 				if !c.IsClient() {
// 					if len(b) == len(ackBinary) {
// 						err := c.serverReadyWaiter.wait()
// 						if err == nil {
// 							// it's ok send ack.
// 							// it's not Ok, send error which client's Dial should return.
// 							c.socket.WriteText(append(ackBinary, []byte(c.id)...), c.writeTimeout)
// 						} else {
// 							c.socket.WriteText(append(ackNotOKBinary, []byte(err.Error())...), c.writeTimeout)
// 							return
// 						}
// 					} else {
// 						// its ackOK, answer from client when ID received and it's ready for write/read.
// 						atomic.StoreUint32(c.acknowledged, 1)
// 						return
// 					}
// 				} else {
// 					id := string(b[len(ackBinary):])
// 					c.id = id
// 					atomic.StoreUint32(c.acknowledged, 1)
// 					c.socket.WriteText(ackOKBinary, c.writeTimeout)
// 					return
// 				}

// 				continue
// 			}
// 		}
// 	}()

// 	if c.IsClient() {
// 		c.write(ackBinary)
// 	}

// }

func (c *Conn) startReader() {
	if c.IsClosed() {
		return
	}
	defer c.Close()

	var (
		// queue       = make([]*Message, 0)
		// queueMutex  = new(sync.Mutex)
		// handleQueue = func() {
		// 	// ready to handle queue when server is ready (if server-side conn).
		// 	c.serverReadyWaiter.wait()

		// 	queueMutex.Lock()
		// 	defer queueMutex.Unlock()

		// 	for _, msg := range queue {
		// 		c.handleMessage(*msg)
		// 	}

		// 	queue = nil
		// }
		allowNativeMessages = c.namespaces[""] != nil && c.namespaces[""][OnNativeMessage] != nil
	)

	// CLIENT is ready when ACK done
	// SERVER is ready when ACK is done AND `Server#OnConnected` returns with nil error.
	for {
		b, err := c.socket.ReadText(c.readTimeout)
		if err != nil {
			return
		}

		// println("[BINARY startReader] " + string(b))
		// if !c.isAcknowledged() && bytes.HasPrefix(b, ackBinary) {
		// 	if c.IsClient() {
		// 		id := string(b[len(ackBinary):])
		// 		c.id = id
		// 		atomic.StoreUint32(c.acknowledged, 1)
		// 		c.socket.WriteText(ackOKBinary, c.writeTimeout)
		// 		handleQueue()
		// 	} else {
		// 		if len(b) == len(ackBinary) {
		// 			c.socket.WriteText(append(ackBinary, []byte(c.id)...), c.writeTimeout)
		// 		} else {
		// 			// its ackOK, answer from client when ID received and it's ready for write/read.
		// 			atomic.StoreUint32(c.acknowledged, 1)
		// 			handleQueue()
		// 		}
		// 	}

		// 	continue
		// }

		msg := deserializeMessage(nil, b, allowNativeMessages)
		if msg.isInvalid {
			// fmt.Printf("%s[%d] is invalid payload\n", b, len(b))
			continue
		}

		// if !c.isAcknowledged()  || !c.serverReadyWaiter.isReady() {
		// 	queueMutex.Lock()
		// 	queue = append(queue, &msg)
		// 	queueMutex.Unlock()
		// 	continue
		// }

		// if !c.handleMessage(msg) {
		// 	return
		// }

		go c.handleMessage(msg)
	}
}

func (c *Conn) isMsgWait(wait string) bool {
	if strings.HasPrefix(wait, "confirmation_") {
		// println("is confirmation of: " + wait)
		return true
	}

	if strings.Contains(wait, "_") {
		return c.IsClient()
	}

	return wait != ""
}

func (c *Conn) handleMessage(msg Message) {
	if c.isMsgWait(msg.wait) {
		c.waitingMessagesMutex.RLock()
		ch, ok := c.waitingMessages[msg.wait]
		c.waitingMessagesMutex.RUnlock()
		if ok {
			ch <- msg
			return
		}
	}

	switch msg.Event {
	case OnNamespaceConnect:
		c.replyConnect(msg)
	case OnNamespaceDisconnect:
		c.replyDisconnect(msg)
	case OnRoomJoin:
		if ns, ok := c.tryNamespace(msg); ok {
			ns.replyRoomJoin(msg)
		}
	case OnRoomLeave:
		if ns, ok := c.tryNamespace(msg); ok {
			ns.replyRoomLeave(msg)
		}
	default:
		ns, ok := c.tryNamespace(msg)
		if !ok {
			// println(msg.Namespace + " namespace and incoming message of event: " + msg.Event + " is not connected or not exists\n\n")
			return
		}

		msg.IsLocal = false
		err := ns.events.fireEvent(ns, msg)
		if err != nil {
			msg.Err = err
			c.Write(msg)
			if isManualCloseError(err) {
				// return false // close the connection after sending the closing message.
				c.Close()
				return
			}
		}
	}

}

const syncWaitDur = 15 * time.Millisecond

// 10 seconds is high value which is not realistic on healthy networks, but may useful for slow connections.
// This value is used just for the ack(which is usually done before the Connect call itself) wait on Connect when on server-side only.
const maxSyncWaitDur = 10 * time.Second

func (c *Conn) Connect(ctx context.Context, namespace string) (*NSConn, error) {
	// if c.IsClosed() {
	// 	return nil, ErrWrite
	// }

	if !c.IsClient() {
		c.serverReadyWaiter.unwait(nil)
		// server-side check for ack-ed, it should be done almost immediately the client connected
		// but give it sometime for slow networks and add an extra check for closed after 5 seconds and a deadline of 10seconds.
		t := maxSyncWaitDur
		for !c.isAcknowledged() {
			time.Sleep(syncWaitDur)
			t = -syncWaitDur

			if t <= maxSyncWaitDur/2 { // check once after 5 seconds if closed.
				if c.IsClosed() {
					return nil, ErrWrite
				}
			}

			if t == 0 {
				// when maxSyncWaitDur passed,
				// we could use the context's deadline but it will make things slower (extracting its value slower than the sleep time).
				if c.IsClosed() {
					return nil, ErrWrite
				}
				return nil, context.DeadlineExceeded
			}
		}
	}

	return c.askConnect(ctx, namespace)
}

// Nil context means try without timeout, wait until it connects to the specific namespace.
// Note that, this function will not return an `ErrBadNamespace` if namespace does not exist in the server-side
// or it's not defined in the client-side, it waits until deadline (if any, or loop forever, so a context with deadline is highly recommended).
func (c *Conn) WaitConnect(ctx context.Context, namespace string) (ns *NSConn, err error) {
	if ctx == nil {
		ctx = context.TODO()
	}

	for {
		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		default:
			if ns == nil {
				ns = c.Namespace(namespace)
			}

			if ns != nil && c.isAcknowledged() {
				return
			}

			time.Sleep(syncWaitDur)
		}
	}
}

func (c *Conn) Namespace(namespace string) *NSConn {
	c.connectedNamespacesMutex.RLock()
	ns := c.connectedNamespaces[namespace]
	c.connectedNamespacesMutex.RUnlock()

	return ns
}

func (c *Conn) tryNamespace(in Message) (*NSConn, bool) {
	ns := c.Namespace(in.Namespace)
	if ns == nil {
		// if _, canConnect := c.namespaces[msg.Namespace]; !canConnect {
		// 	msg.Err = ErrForbiddenNamespace
		// }
		in.Err = ErrBadNamespace
		c.Write(in)
		return nil, false
	}

	return ns, true
}

// server#OnConnected -> conn#Connect
// client#WaitConnect
// or
// client#Connect
func (c *Conn) askConnect(ctx context.Context, namespace string) (*NSConn, error) {
	ns := c.Namespace(namespace)
	if ns != nil {
		return ns, nil
	}

	events, ok := c.namespaces[namespace]
	if !ok {
		return nil, ErrBadNamespace
	}

	connectMessage := Message{
		Namespace: namespace,
		Event:     OnNamespaceConnect,
		IsLocal:   true,
	}

	// println("ask connect")
	_, err := c.Ask(ctx, connectMessage) // waits for answer no matter if already connected on the other side.
	if err != nil {
		return nil, err
	}
	// println("got connect")
	// re-check, maybe connected so far (can happen by a simultaneously `Connect` calls on both server and client, which is not the standard way)
	c.connectedNamespacesMutex.RLock()
	ns, ok = c.connectedNamespaces[namespace]
	c.connectedNamespacesMutex.RUnlock()
	if ok {
		return ns, nil
	}

	ns = newNSConn(c, namespace, events)
	err = events.fireEvent(ns, connectMessage)
	if err != nil {
		return nil, err
	}

	c.connectedNamespacesMutex.Lock()
	c.connectedNamespaces[namespace] = ns
	c.connectedNamespacesMutex.Unlock()

	// println("write confirmation: " + "confirmation_" + reply.wait)
	// c.writeEmptyReply("confirmation_" + reply.wait)
	connectMessage.Event = OnNamespaceConnected
	events.fireEvent(ns, connectMessage) // omit error, it's connected.

	return ns, nil
}

func (c *Conn) replyConnect(msg Message) {
	// must give answer even a noOp if already connected.
	if msg.wait == "" || msg.isNoOp {
		return
	}

	ns := c.Namespace(msg.Namespace)
	if ns != nil {
		c.writeEmptyReply(msg.wait)
		return
	}

	events, ok := c.namespaces[msg.Namespace]
	if !ok {
		msg.Err = ErrBadNamespace
		c.Write(msg)
		return
	}

	ns = newNSConn(c, msg.Namespace, events)
	err := events.fireEvent(ns, msg)
	if err != nil {
		msg.Err = err
		c.Write(msg)
		return
	}

	c.connectedNamespacesMutex.Lock()
	c.connectedNamespaces[msg.Namespace] = ns
	c.connectedNamespacesMutex.Unlock()

	c.writeEmptyReply(msg.wait)

	// c.waitConfirmation(nil, msg.wait)
	// println("confirmation got")
	msg.Event = OnNamespaceConnected
	events.fireEvent(ns, msg)
}

func (c *Conn) DisconnectAll(ctx context.Context) error {
	c.connectedNamespacesMutex.Lock()
	defer c.connectedNamespacesMutex.Unlock()

	disconnectMsg := Message{Event: OnNamespaceDisconnect, IsLocal: true, locked: true}
	for namespace := range c.connectedNamespaces {
		disconnectMsg.Namespace = namespace
		if err := c.askDisconnect(ctx, disconnectMsg, false); err != nil {
			return err
		}
	}

	return nil
}

func (c *Conn) askDisconnect(ctx context.Context, msg Message, lock bool) error {
	if lock {
		c.connectedNamespacesMutex.RLock()
	}

	ns := c.connectedNamespaces[msg.Namespace]

	if lock {
		c.connectedNamespacesMutex.RUnlock()
	}

	if ns == nil {
		return ErrBadNamespace
	}

	_, err := c.Ask(ctx, msg)
	if err != nil {
		return err
	}

	// if disconnect is allowed then leave rooms first with force property
	// before namespace's deletion.
	ns.forceLeaveAll(true)

	if lock {
		c.connectedNamespacesMutex.Lock()
	}

	delete(c.connectedNamespaces, msg.Namespace)

	if lock {
		c.connectedNamespacesMutex.Unlock()
	}

	msg.IsLocal = true
	ns.events.fireEvent(ns, msg)

	return nil
}

func (c *Conn) replyDisconnect(msg Message) {
	if msg.wait == "" || msg.isNoOp {
		return
	}

	ns := c.Namespace(msg.Namespace)
	if ns == nil {
		c.writeEmptyReply(msg.wait)
		return
	}

	// if client then we need to respond to server and delete the namespace without ask the local event.
	if c.IsClient() {
		// if disconnect is allowed then leave rooms first with force property
		// before namespace's deletion.
		ns.forceLeaveAll(false)

		c.connectedNamespacesMutex.Lock()
		delete(c.connectedNamespaces, msg.Namespace)
		c.connectedNamespacesMutex.Unlock()

		c.writeEmptyReply(msg.wait)

		ns.events.fireEvent(ns, msg)
		return
	}

	// server-side, check for error on the local event first.
	err := ns.events.fireEvent(ns, msg)
	if err != nil {
		msg.Err = err
		c.Write(msg)
		return
	}

	ns.forceLeaveAll(false)

	c.connectedNamespacesMutex.Lock()
	delete(c.connectedNamespaces, msg.Namespace)
	c.connectedNamespacesMutex.Unlock()

	c.writeEmptyReply(msg.wait)
}

func (c *Conn) write(b []byte) bool {
	err := c.socket.WriteText(b, c.writeTimeout)
	if err != nil {
		if IsCloseError(err) {
			c.Close()
		}
		return false
	}

	return true
}

func (c *Conn) Write(msg Message) bool {
	if c.IsClosed() {
		return false
	}

	//	println("c.Write")
	c.serverReadyWaiter.unwait(nil) // for server-side if tries to send, then error will be not ignored but events should continue.
	//	fmt.Printf("c.Write: %#+v\n", msg)

	// msg.from = c.ID()

	if !msg.isConnect() && !msg.isDisconnect() {
		if !msg.locked {
			c.connectedNamespacesMutex.RLock()
		}

		ns := c.connectedNamespaces[msg.Namespace]

		if !msg.locked {
			c.connectedNamespacesMutex.RUnlock()
		}

		if ns == nil {
			return false
		}

		if msg.Room != "" && !msg.isRoomJoin() && !msg.isRoomLeft() {
			if !msg.locked {
				ns.roomsMutex.RLock()
			}

			_, ok := ns.rooms[msg.Room]

			if !msg.locked {
				ns.roomsMutex.RUnlock()
			}

			if !ok {
				// tried to send to a not joined room.
				return false
			}
		}
	}

	return c.write(serializeMessage(nil, msg))
}

// used when `Ask` caller cares only for successful call and not the message, for performance reasons we just use raw bytes.
func (c *Conn) writeEmptyReply(wait string) bool {
	return c.write(genEmptyReplyToWait(wait))
}

func (c *Conn) waitConfirmation(ctx context.Context, wait string) error {
	if c.IsClosed() {
		return ErrWrite
	}

	wait = "confirmation_" + wait
	ch := make(chan Message)
	c.waitingMessagesMutex.Lock()
	c.waitingMessages[wait] = ch
	c.waitingMessagesMutex.Unlock()

	if ctx == nil {
		ctx = context.Background()
	}

	// println("waiting for confirmation: " + wait)
	select {
	case <-ctx.Done():
		if c.IsClosed() {
			return ErrWrite
		}
		return ctx.Err()
	case receive := <-ch:
		c.waitingMessagesMutex.Lock()
		delete(c.waitingMessages, receive.wait)
		c.waitingMessagesMutex.Unlock()
		return receive.Err
	}
}

func (c *Conn) Ask(ctx context.Context, msg Message) (Message, error) {
	if c.IsClosed() {
		return msg, CloseError{Code: -1, error: ErrWrite}
	}

	now := time.Now().UnixNano()
	msg.wait = strconv.FormatInt(now, 10)
	if c.IsClient() {
		msg.wait = "client_" + msg.wait
	}

	if ctx == nil {
		ctx = context.TODO()
	} else {
		if deadline, has := ctx.Deadline(); has {
			if deadline.Before(time.Now().Add(-1 * time.Second)) {
				return Message{}, context.DeadlineExceeded
			}
		}
	}

	ch := make(chan Message)
	c.waitingMessagesMutex.Lock()
	c.waitingMessages[msg.wait] = ch
	c.waitingMessagesMutex.Unlock()

	if !c.Write(msg) {
		return Message{}, ErrWrite
	}

	select {
	case <-ctx.Done():
		if c.IsClosed() {
			return Message{}, ErrWrite
		}
		return Message{}, ctx.Err()
	case receive := <-ch:
		c.waitingMessagesMutex.Lock()
		delete(c.waitingMessages, receive.wait)
		c.waitingMessagesMutex.Unlock()

		return receive, receive.Err
	}
}

func (c *Conn) Close() {
	if atomic.CompareAndSwapUint32(c.closed, 0, 1) {
		close(c.closeCh)

		disconnectMsg := Message{Event: OnNamespaceDisconnect, IsForced: true, IsLocal: true}
		c.connectedNamespacesMutex.Lock()
		for namespace, ns := range c.connectedNamespaces {
			// leave rooms first with force and local property before remove the namespace completely.
			ns.forceLeaveAll(true)

			disconnectMsg.Namespace = ns.namespace
			ns.events.fireEvent(ns, disconnectMsg)
			delete(c.connectedNamespaces, namespace)
		}
		c.connectedNamespacesMutex.Unlock()

		c.waitingMessagesMutex.Lock()
		for wait := range c.waitingMessages {
			delete(c.waitingMessages, wait)
		}
		c.waitingMessagesMutex.Unlock()

		atomic.StoreUint32(c.acknowledged, 0)

		go func() {
			if !c.IsClient() {
				c.server.disconnect <- c
			}
		}()

		c.socket.NetConn().Close()
	}
}

func (c *Conn) IsClosed() bool {
	return atomic.LoadUint32(c.closed) > 0
}
